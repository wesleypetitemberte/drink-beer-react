/**
 * @remix-run/dev v2.5.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('node:path');
var fse = require('fs-extra');
var pc = require('picocolors');
var plugin = require('./plugin.js');
var invariant = require('../invariant.js');
var importViteEsmSync = require('./import-vite-esm-sync.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fse__default = /*#__PURE__*/_interopDefaultLegacy(fse);
var pc__default = /*#__PURE__*/_interopDefaultLegacy(pc);

async function extractConfig({
  configFile,
  mode,
  root
}) {
  let vite = await import('vite');

  // Leverage the Vite config as a way to configure the entire multi-step build
  // process so we don't need to have a separate Remix config
  let viteConfig = await vite.resolveConfig({
    mode,
    configFile,
    root
  }, "build",
  // command
  "production",
  // default mode
  "production" // default NODE_ENV
  );
  let pluginConfig = viteConfig["__remixPluginResolvedConfig"];
  if (!pluginConfig) {
    console.error(pc__default["default"].red("Remix Vite plugin not found in Vite config"));
    process.exit(1);
  }
  return {
    pluginConfig,
    viteConfig
  };
}
function getAddressableRoutes(routes) {
  let nonAddressableIds = new Set();
  for (let id in routes) {
    let route = routes[id];

    // We omit the parent route of index routes since the index route takes ownership of its parent's path
    if (route.index) {
      invariant["default"](route.parentId, `Expected index route "${route.id}" to have "parentId" set`);
      nonAddressableIds.add(route.parentId);
    }

    // We omit pathless routes since they can only be addressed via descendant routes
    if (typeof route.path !== "string" && !route.index) {
      nonAddressableIds.add(id);
    }
  }
  return Object.values(routes).filter(route => !nonAddressableIds.has(route.id));
}
function getRouteBranch(routes, routeId) {
  let branch = [];
  let currentRouteId = routeId;
  while (currentRouteId) {
    let route = routes[currentRouteId];
    invariant["default"](route, `Missing route for ${currentRouteId}`);
    branch.push(route);
    currentRouteId = route.parentId;
  }
  return branch.reverse();
}
async function getServerBuilds({
  routes,
  serverBuildDirectory,
  serverBuildFile,
  serverBundles,
  rootDirectory,
  appDirectory
}) {
  if (!serverBundles) {
    return {
      serverBuilds: [{
        routes,
        serverBuildDirectory
      }]
    };
  }
  let {
    normalizePath
  } = await import('vite');
  let resolvedAppDirectory = path__default["default"].resolve(rootDirectory, appDirectory);
  let rootRelativeRoutes = Object.fromEntries(Object.entries(routes).map(([id, route]) => {
    let filePath = path__default["default"].join(resolvedAppDirectory, route.file);
    let rootRelativeFilePath = normalizePath(path__default["default"].relative(rootDirectory, filePath));
    return [id, {
      ...route,
      file: rootRelativeFilePath
    }];
  }));
  let serverBundlesManifest = {
    serverBundles: {},
    routeIdToServerBundleId: {},
    routes: rootRelativeRoutes
  };
  let serverBuildConfigByBundleId = new Map();
  await Promise.all(getAddressableRoutes(routes).map(async route => {
    let branch = getRouteBranch(routes, route.id);
    let bundleId = await serverBundles({
      branch: branch.map(route => plugin.configRouteToBranchRoute({
        ...route,
        // Ensure absolute paths are passed to the serverBundles function
        file: path__default["default"].join(resolvedAppDirectory, route.file)
      }))
    });
    if (typeof bundleId !== "string") {
      throw new Error(`The "unstable_serverBundles" function must return a string`);
    }
    serverBundlesManifest.routeIdToServerBundleId[route.id] = bundleId;
    let serverBundleDirectory = path__default["default"].join(serverBuildDirectory, bundleId);
    let serverBuildConfig = serverBuildConfigByBundleId.get(bundleId);
    if (!serverBuildConfig) {
      serverBundlesManifest.serverBundles[bundleId] = {
        id: bundleId,
        file: normalizePath(path__default["default"].join(serverBundleDirectory, serverBuildFile))
      };
      serverBuildConfig = {
        routes: {},
        serverBuildDirectory: serverBundleDirectory
      };
      serverBuildConfigByBundleId.set(bundleId, serverBuildConfig);
    }
    for (let route of branch) {
      serverBuildConfig.routes[route.id] = route;
    }
  }));
  return {
    serverBuilds: Array.from(serverBuildConfigByBundleId.values()),
    serverBundlesManifest
  };
}
async function cleanServerBuildDirectory(viteConfig, {
  rootDirectory,
  serverBuildDirectory
}) {
  let isWithinRoot = () => {
    let relativePath = path__default["default"].relative(rootDirectory, serverBuildDirectory);
    return !relativePath.startsWith("..") && !path__default["default"].isAbsolute(relativePath);
  };
  if (viteConfig.build.emptyOutDir ?? isWithinRoot()) {
    await fse__default["default"].remove(serverBuildDirectory);
  }
}
async function build(root, {
  assetsInlineLimit,
  clearScreen,
  config: configFile,
  emptyOutDir,
  force,
  logLevel,
  minify,
  mode
}) {
  // Ensure Vite's ESM build is preloaded at the start of the process
  // so it can be accessed synchronously via `importViteEsmSync`
  await importViteEsmSync.preloadViteEsm();
  let {
    pluginConfig,
    viteConfig
  } = await extractConfig({
    configFile,
    mode,
    root
  });
  let vite = await import('vite');
  async function viteBuild(serverBuildConfig) {
    let ssr = Boolean(serverBuildConfig);
    await vite.build({
      root,
      mode,
      configFile,
      build: {
        assetsInlineLimit,
        emptyOutDir,
        minify,
        ssr
      },
      optimizeDeps: {
        force
      },
      clearScreen,
      logLevel,
      ...(serverBuildConfig ? {
        __remixServerBuildConfig: serverBuildConfig
      } : {})
    });
  }

  // Since we're potentially running multiple Vite server builds with different
  // output directories, we need to clean the root server build directory
  // ourselves rather than relying on Vite to do it, otherwise you can end up
  // with stale server bundle directories in your build output
  await cleanServerBuildDirectory(viteConfig, pluginConfig);

  // Run the Vite client build first
  await viteBuild();

  // Then run Vite SSR builds in parallel
  let {
    serverBuilds,
    serverBundlesManifest
  } = await getServerBuilds(pluginConfig);
  await Promise.all(serverBuilds.map(viteBuild));
  if (serverBundlesManifest) {
    await fse__default["default"].writeFile(path__default["default"].join(pluginConfig.serverBuildDirectory, "bundles.json"), JSON.stringify(serverBundlesManifest, null, 2), "utf-8");
  }
}

exports.build = build;
